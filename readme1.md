# Pediatric RCM Automation Pipeline
**An AI-powered, multi-agent medical billing system built on Google ADK + AWS Serverless**

---

## Table of Contents

- [What is this?](#what-is-this)
- [Key Concepts / What you'll learn](#key-concepts--what-youll-learn)
- [Screenshots & Design Docs](#screenshots--design-docs)
- [Architecture Overview](#architecture-overview)
- [Testing & Verification](#testing--verification)
- [How to Run](#how-to-run)
- [Repository Map](#repository-map)
- [UML / Diagrams](#uml--diagrams)

---

## What is this?

This is a learning project I built to explore **Google ADK (Agent Development Kit)** while solving a real-world problem: automating pediatric medical billing workflows. The system reads raw physician notes, extracts clinical entities, maps them to ICD-10 and CPT codes, audits billing accuracy, and generates compliance-ready encounter reports—all orchestrated by a multi-agent pipeline deployed as an AWS Lambda function.

It's my practical playground for understanding agent orchestration patterns, context persistence, iterative refinement loops, and serverless deployment strategies. The codebase demonstrates both **local ADK development** and **production AWS deployments** using SAM (Serverless Application Model), Docker, and ECR.

---

## Key Concepts / What you'll learn

- **Multi-Agent Orchestration**: How to chain specialized agents (extractor → coder → auditor → finalizer) using ADK's `SequentialAgent` and `LoopAgent` primitives
- **Iterative Refinement Pattern**: A loop agent that keeps refining billing codes until they pass a 90%+ confidence audit
- **Stateful Context Management**: How ADK's `InMemorySessionService` persists agent outputs across the pipeline
- **Async Worker Pattern**: Decoupling client requests from long-running agent workflows using Lambda async invocations
- **Knowledge-Grounded Tools**: Custom tools that let agents search a medical billing knowledge base without hallucinating codes
- **Serverless Multi-API Design**: One API Gateway handling both client requests (`POST /process-encounter`, `GET /status/{jobId}`) and internal agent coordination
- **AWS Deployment**: Docker + ECR + Lambda + DynamoDB + SAM infrastructure-as-code

---

## Screenshots & Design Docs

### Screenshots

**Postman: Submitting a Patient Note**

![Postman POST Request](images/Postman_PostApi.png)

**Request:**
```json
POST https://gphrvfly1e.execute-api.us-east-1.amazonaws.com/Prod/process-encounter?hello

Headers:
  Content-Type: application/json

Body:
{
  "note": "4-year-old male presents with bilateral eye redness and watery discharge for 2 days. Mother reports crusting on eyelids upon waking in the morning. Child complains of itching but denies pain or vision changes. Diagnosis: Acute bilateral conjunctivitis"
}
```

**Response:**
```json
Status: 202 Accepted
Duration: 3.92 s

{
  "jobId": "077a5b2b-ffe3-4939-967f-be4acc51e0b9",
  "message": "Flow started"
}
```

---

**Postman: Polling Job Status**

![Postman GET Status](images/Postman_GetApi.png)

**Request:**
```http
GET https://gphrvfly1e.execute-api.us-east-1.amazonaws.com/Prod/status/fc568861-26e5-4c19-bc52-756905640906 

Headers: (6 total - auto-generated by Postman)
```

**Response:**
```json
Status: 200 OK
Duration: 557 ms
Size: 924 B

{
  "jobId": "077a5b2b-ffe3-4939-967f-be4acc51e0b9",
  "result": "# [FINAL-ENCOUNTER-RECORD] Pediatric Associates\n\nFinal Confidence Score: 100\nFinal Status: APPROVED\n\n## 2. Billing Summary\n* **Primary ICD-10:** H10.33 - Unspecified acute conjunctivitis, bilateral\n* **Supporting CPTs:** 99212\n* **Integrity Check:** Confirming Age-logic and clinical alignment.",
  "status": "Completed"
}
```

<details>
<summary><strong>Click to view full billing report</strong></summary>

```markdown
# [FINAL-ENCOUNTER-RECORD] Pediatric Associates

Final Confidence Score: 100
Final Status: APPROVED

## 2. Billing Summary
Primary ICD-10: H10.33 - Unspecified acute conjunctivitis, bilateral
Supporting CPTs: 99212
Integrity Check: Confirming Age-logic and clinical alignment.
```

**Agent Processing Summary:**
- Clinical Entity Extractor: Identified bilateral conjunctivitis, 4-year-old male
- Medical Coder Agent: Mapped to ICD-10 H10.33 + CPT 99212
- Revenue Integrity Judge: Approved with 100% confidence score
- Billing Finalizer: Generated final encounter record

</details>

---

### ADK Local Development Interface

<details open>
<summary><strong>Click to expand ADK Web UI screenshots</strong></summary>

#### ADK: Workflow Architecture Diagram

![ADK Workflow Architecture](images/GoogleAdk_Sample_Workflow_Diagram.png)

**Auto-generated by Google ADK** - Visual representation of the multi-agent pipeline.

---

#### ADK: Agent Execution Trace - Clinical Extraction

![ADK Trace - Clinical Extraction](images/GoogleAdk_TraveView_1.png)

**Phase 1: ClinicalEntityExtractor** (Orange icons)
- Calls tools: `onboard_project` → `list_git_files` → `read_file`
- Output: Structured clinical specification with laterality, diagnosis, and target ICD-10/CPT ranges

---

#### ADK: Agent Execution Trace - Billing Refinement & Approval

![ADK Trace - Billing Refinement](images/GoogleAdk_TraveView_2.png)

**Phase 2-3: BillingRefinementLoop** (Pink/Purple icons)
- **MedicalCoderAgent**: Searches knowledge base 11× → Proposes ICD-10 H10.33 + CPT 99212
- **RevenueIntegrityJudge**: Verifies codes → Confidence: 100% → APPROVED → Loop exits
- **BillingFinalizer**: Generates final encounter record

</details>

---

### Design Docs

Key architectural decisions are documented in [`docs/design-decisions.md`](./docs/design_decisions.md).

**Decisions covered:**
- **Docker + ECR**: Why we use containers instead of Lambda layers (dependency size: 320MB > 250MB limit)
- **DynamoDB**: Why we chose DynamoDB over RDS or S3 (serverless, pay-per-request, sub-10ms latency)
- **Two APIs (POST + GET)**: Why async processing is necessary (API Gateway 29-second timeout, agents take 30-90s)

Each decision includes context, rationale, trade-offs, and alternatives considered.

---

## Architecture Overview

### System Components

```mermaid
graph TB
    Client[Client<br/>Postman / Web App / CLI]
    
    POST_API[POST /process-encounter<br/>Submit patient note]
    GET_API[GET /status/:jobId<br/>Check job status]
    
    Lambda[Lambda Function<br/>PediatricRcmFunction]
    
    Dispatcher[Dispatcher Mode<br/>handle_post_flow]
    StatusCheck[Status Check Mode<br/>handle_get_flow]
    Worker[Worker Mode<br/>handle_worker_flow]
    
    DDB[(DynamoDB<br/>PediatricRcmResults)]
    Gemini[Google Gemini API<br/>LLM Inference]
    
    ECR[ECR<br/>Docker Image]
    Secrets[Secrets Manager<br/>API Key]
    Logs[CloudWatch Logs]
    
    %% POST Flow (Left side)
    Client ==>|1. POST note| POST_API
    POST_API ==>|2. Route| Dispatcher
    Dispatcher ==>|3. Write Running| DDB
    Dispatcher ==>|4. Return 202 + jobId| Client
    Dispatcher -.->|5. Async invoke| Worker
    Worker ==>|6. Call LLM| Gemini
    Worker ==>|7. Write Completed| DDB
    
    %% GET Flow (Right side)
    Client ==>|8. GET status| GET_API
    GET_API ==>|9. Route| StatusCheck
    StatusCheck ==>|10. Read| DDB
    StatusCheck ==>|11. Return result| Client
    
    %% Infrastructure connections
    Lambda ---|Uses| ECR
    Lambda ---|Uses| Secrets
    Lambda ---|Logs to| Logs
    
    %% Styling - High contrast colors
    style Client fill:#b3e5fc,stroke:#01579b,stroke-width:4px,color:#000
    style POST_API fill:#ffcc80,stroke:#e65100,stroke-width:4px,color:#000
    style GET_API fill:#ffcc80,stroke:#e65100,stroke-width:4px,color:#000
    style Lambda fill:#fff59d,stroke:#f57f17,stroke-width:4px,color:#000
    style Dispatcher fill:#fff9c4,stroke:#f57f17,stroke-width:3px,color:#000
    style StatusCheck fill:#fff9c4,stroke:#f57f17,stroke-width:3px,color:#000
    style Worker fill:#fff9c4,stroke:#f57f17,stroke-width:3px,color:#000
    style DDB fill:#ce93d8,stroke:#4a148c,stroke-width:4px,color:#000
    style Gemini fill:#90caf9,stroke:#0d47a1,stroke-width:4px,color:#000
    style ECR fill:#ffab91,stroke:#bf360c,stroke-width:2px,color:#000
    style Secrets fill:#f48fb1,stroke:#880e4f,stroke-width:2px,color:#000
    style Logs fill:#ffab91,stroke:#bf360c,stroke-width:2px,color:#000
```

---

### Request Flow

**POST Flow (Submit Job):**
1. Client submits patient note → `POST /process-encounter`
2. API Gateway routes to **Dispatcher Mode** (Lambda)
3. Dispatcher writes `{jobId, status: "Running"}` to DynamoDB
4. Dispatcher returns `202 Accepted {jobId}` to client immediately
5. Dispatcher invokes **Worker Mode** async (non-blocking)
6. Worker calls Gemini API to process patient note
7. Worker writes `{status: "Completed", result: report}` to DynamoDB

**GET Flow (Check Status):**
8. Client polls for results → `GET /status/:jobId`
9. API Gateway routes to **Status Check Mode** (Lambda)
10. Status Check reads job data from DynamoDB
11. Status Check returns `{jobId, status, result}` to client

**Infrastructure:**
- **Lambda** pulls Docker image from ECR at startup
- **Lambda** fetches Google API key from Secrets Manager
- **Lambda** streams execution logs to CloudWatch

---

## Testing & Verification

### A) Local Testing

#### Unit Tests (Moto-based Integration Test)

The repo includes a full end-to-end test using AWS service mocks:

```bash
# Install test dependencies
pip install pytest moto boto3

# Run the test suite
python test/handler_test.py
```

**What this tests:**
- POST flow: Creates a job ID and stores "Running" status in DynamoDB
- Worker flow: Manually triggers the ADK pipeline (simulates async invoke)
- GET flow: Polls the job status and retrieves the final report

**Sample output:**
```
--- 1. Testing POST Flow ---
Loading scenario from: test/scenarios/scenario_1_ear_infection.json
Job Created: 5a7f3c21-8b9d-4e2a-9f1e-6d4c8b3a2e1f

--- 2. Manually Triggering Worker Flow ---
Worker execution finished.

--- 3. Testing GET Flow for Result ---
Final Report Retrieved:
[FINAL-ENCOUNTER-RECORD] Pediatric Associates
Final Confidence Score: 95
Final Status: APPROVED
...
```

### B) ADK Local Testing

You can run the agent pipeline **without AWS** using ADK's local web UI:

```bash
# 1. Install dependencies
pip install -r requirements.txt

# 2. Set environment variables
export GOOGLE_API_KEY="your-gemini-api-key"

# 3. Run ADK's local server
adk web start --agent agents.development_workflow.agent:root_agent --app-name pediatric-rcm-automation

# 4. Open http://localhost:8080 in your browser
```

**What you'll see:**
- A chat interface to submit patient notes
- Real-time agent execution logs (which agent is running, what tools are called)
- The full conversation history with `state` snapshots

**Sample workflow:**
```
You: "5-year-old with right ear pain, fever, red tympanic membrane. Administered nebulizer."

[Agent Trace]
1. ClinicalEntityExtractor → Reading knowledge_base/billing_codes.md → Extracting laterality: RIGHT
2. BillingRefinementLoop (Iteration 1)
   - MedicalCoderAgent → Searching "Ear Infection Right" → Proposing H66.001 + 99213
   - RevenueIntegrityJudge → Confidence: 85% (missing nebulizer CPT) → NEEDS_REVISION
3. BillingRefinementLoop (Iteration 2)
   - MedicalCoderAgent → Adding CPT 94640 (nebulizer)
   - RevenueIntegrityJudge → Confidence: 95% → APPROVED
4. BillingFinalizer → Generating final report
```

### C) AWS Deployment Testing

After deploying to AWS (see [How to Run](#how-to-run)), test the live API:

#### Health Check (Smoke Test)

```bash
# Get your API URL from SAM output
export API_URL="https://abcd1234.execute-api.us-east-1.amazonaws.com/Prod"

# Test POST endpoint
curl -X POST $API_URL/process-encounter \
  -H "Content-Type: application/json" \
  -d '{"note": "5-year-old with right ear pain"}'

# Expected response:
# {"jobId": "uuid-here", "message": "Flow started"}
```

#### End-to-End Workflow Test

```bash
# 1. Submit a job
JOB_ID=$(curl -s -X POST $API_URL/process-encounter \
  -H "Content-Type: application/json" \
  -d '{"note": "7-year-old with bilateral ear infection, fever 101F, red tympanic membranes"}' \
  | jq -r '.jobId')

echo "Job ID: $JOB_ID"

# 2. Poll status (repeat until status is "Completed")
curl -s $API_URL/status/$JOB_ID | jq .

# 3. Verify the result contains expected codes
curl -s $API_URL/status/$JOB_ID | jq -r '.result' | grep "H66.003"  # Bilateral ear infection
```

#### CloudWatch Logs

```bash
# Stream Lambda logs
sam logs --name PediatricRcmFunction --stack-name PediatricRcmAutomationStack --tail

# Look for:
# - "[AGENT: ClinicalEntityExtractor] processing..."
# - "WORKER SUCCESS: Job {jobId} complete."
```

---

## How to Run

### A) Local (Python + ADK CLI)

**Prerequisites:**
- Python 3.13+ (matches Lambda runtime)
- Google Gemini API key ([get one here](https://ai.google.dev/))

**Setup:**

```bash
# 1. Clone the repo
git clone https://github.com/tarikkatasoy/pediatric-rcm-automation.git
cd pediatric-rcm-automation

# 2. Install dependencies
pip install -r requirements.txt

# 3. Set environment variables
export GOOGLE_API_KEY="your-gemini-api-key"
export RESULTS_TABLE="PediatricRcmResults"  # Dummy value for local testing
export AWS_DEFAULT_REGION="us-east-1"       # Dummy value for local testing
```

**Run ADK Web UI:**

```bash
adk web start --agent agents.development_workflow.agent:root_agent --app-name pediatric-rcm-automation
```

Open http://localhost:8080 and submit a patient note:

```
7-year-old with bilateral ear infection, fever 101F, red tympanic membranes. Administered nebulizer.
```

**Run Unit Tests:**

```bash
python test/handler_test.py
```

---

### B) ADK (Agent Development Kit Local Mode)

If you want to test the agents in isolation (without the Lambda handler):

```bash
# 1. Ensure GOOGLE_API_KEY is set
export GOOGLE_API_KEY="your-gemini-api-key"

# 2. Start ADK web server
adk web start --agent agents.development_workflow.agent:root_agent

# 3. Open http://localhost:8080
```

**Tip:** The ADK web UI shows:
- Which agent is currently running
- What tools it's calling (`read_file`, `search_knowledge_base`, etc.)
- The intermediate `state` after each agent completes

---

### C) AWS Deployment (SAM + Docker + ECR)

**Prerequisites:**
- AWS CLI configured ([setup guide](https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html))
- SAM CLI installed ([install SAM](https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/install-sam-cli.html))
- Docker Desktop running
- IAM permissions for:
  - CloudFormation
  - Lambda
  - API Gateway
  - DynamoDB
  - ECR
  - Secrets Manager

**Step 1: Store Your Google API Key in Secrets Manager**

```bash
aws secretsmanager create-secret \
  --name PediatricRcmGeminiKey \
  --secret-string '{"API_KEY":"your-actual-gemini-api-key"}' \
  --region us-east-1
```

**Step 2: Build & Deploy with SAM**

```bash
# Build the Docker image and package the Lambda function
sam build

# Deploy (first time: creates ECR repo, DynamoDB table, API Gateway)
sam deploy --guided

# Follow the prompts:
# - Stack Name: PediatricRcmAutomationStack
# - AWS Region: us-east-1
# - Confirm changes before deploy: Y
# - Allow SAM CLI IAM role creation: Y
# - Disable rollback: N (recommended for production; we use Y for dev)
# - PediatricRcmFunction may not have authorization defined: Y
# - Save arguments to configuration file: Y
```

SAM will:
1. Build the Docker image (using [`Dockerfile`](./Dockerfile))
2. Create an ECR repository (auto-named by SAM)
3. Push the image to ECR
4. Deploy a CloudFormation stack with:
   - Lambda function (3GB RAM, 300s timeout, arm64 architecture)
   - API Gateway (with `/process-encounter` and `/status/{jobId}` routes)
   - DynamoDB table (`PediatricRcmResults`)
5. Output the API URL

**Step 3: Get Your API URL**

```bash
aws cloudformation describe-stacks \
  --stack-name PediatricRcmAutomationStack \
  --query "Stacks[0].Outputs[?OutputKey=='ApiUrl'].OutputValue" \
  --output text
```

Save this URL as `API_URL` for testing.

**Step 4: Test the Deployment**

```bash
export API_URL="https://your-api-id.execute-api.us-east-1.amazonaws.com/Prod"

# Submit a test job
curl -X POST $API_URL/process-encounter \
  -H "Content-Type: application/json" \
  -d '{"note": "5-year-old with right ear pain, fever, red tympanic membrane"}'

# Get the jobId from the response, then poll status:
curl $API_URL/status/{jobId}
```

**Step 5: Redeploy After Code Changes**

```bash
# Rebuild + redeploy (no --guided needed after first deploy)
sam build && sam deploy
```

**Step 6: View Logs**

```bash
sam logs --name PediatricRcmFunction --stack-name PediatricRcmAutomationStack --tail
```

---

## Repository Map

```
pediatric-rcm-automation/
├── agents/                          # ADK agent definitions
│   └── development_workflow/
│       ├── agent.py                 # Root agent (SequentialAgent + LoopAgent)
│       ├── common_tools.py          # Shared tools (read_file, search_knowledge_base)
│       └── subagents/
│           ├── clinical_entity_extractor/
│           │   └── agent.py         # Extracts clinical findings from notes
│           ├── medical_coder/
│           │   └── agent.py         # Maps findings → ICD-10 + CPT codes
│           ├── revenue_integrity_judge/
│           │   ├── agent.py         # Audits billing accuracy
│           │   └── tools.py         # set_review_status_and_exit_if_approved()
│           └── billing_finalizer/
│               └── agent.py         # Generates final encounter report
│
├── knowledge_base/
│   └── billing_codes.md             # Master reference: ICD-10 + CPT codes + scenarios
│
├── test/
│   ├── handler_test.py              # Full end-to-end test (POST → Worker → GET)
│   └── scenarios/                   # Sample patient notes for testing
│       └── scenario_1_ear_infection.json
│
├── handler.py                       # AWS Lambda entry point (multi-mode routing)
├── Dockerfile                       # Containerizes the app for Lambda
├── template.yml                     # SAM/CloudFormation infrastructure definition
├── samconfig.toml                   # SAM deployment configuration (stack name, region, ECR)
├── requirements.txt                 # Python dependencies (ADK, google-genai, boto3)
├── .gitignore                       # Excludes .venv, .aws-sam, etc.
└── README.md                        # You are here
```

---

## UML / Diagrams

### A) Communication Patterns (Invoker ↔ Agents)

```mermaid
sequenceDiagram
    participant Client
    participant Lambda
    participant DynamoDB
    participant ADK_Runner
    participant Extractor as ClinicalEntityExtractor
    participant RefinementLoop as BillingRefinementLoop
    participant Coder as MedicalCoderAgent
    participant Judge as RevenueIntegrityJudge
    participant Finalizer as BillingFinalizer

    Client->>Lambda: POST /process-encounter {note}
    Lambda->>DynamoDB: Write {jobId, status: Running}
    Lambda->>Lambda: Async invoke (Worker mode)
    Lambda-->>Client: 202 {jobId}

    Note over Lambda: Worker Mode Starts
    Lambda->>ADK_Runner: run(session_id, message)
    
    ADK_Runner->>Extractor: Execute
    Extractor->>Extractor: read_file(knowledge_base)
    Extractor->>Extractor: Extract findings
    Extractor->>ADK_Runner: Return clinical_summary
    
    ADK_Runner->>RefinementLoop: Execute (max 5 iterations)
    
    loop Until confidence >= 90%
        RefinementLoop->>Coder: Execute
        Coder->>Coder: search_knowledge_base
        Coder->>Coder: Map to ICD-10 and CPT
        Coder->>RefinementLoop: Return billing_draft
        
        RefinementLoop->>Judge: Execute
        Judge->>Judge: Audit codes
        Judge->>Judge: Calculate confidence_score
        
        alt Confidence >= 90%
            Judge->>RefinementLoop: APPROVED, escalate=True
            RefinementLoop->>ADK_Runner: Exit loop
        else Confidence < 90%
            Judge->>RefinementLoop: NEEDS_REVISION
            Note over RefinementLoop: Send feedback to Coder
        end
    end
    
    ADK_Runner->>Finalizer: Execute
    Finalizer->>Finalizer: Consolidate billing_draft
    Finalizer->>ADK_Runner: Return final_billing_report
    
    ADK_Runner->>Lambda: Return final_report
    Lambda->>DynamoDB: Update status: Completed
    
    Client->>Lambda: GET /status/{jobId}
    Lambda->>DynamoDB: Query jobId
    DynamoDB-->>Lambda: Return status and result
    Lambda-->>Client: 200 {jobId, status, result}
```

---

### B) AWS Deployment Architecture

```mermaid
graph TB
    subgraph "Client Layer"
        A[Web App / Postman / CLI]
    end
    
    subgraph "AWS us-east-1"
        subgraph "API Layer"
            B[API Gateway<br/>POST /process-encounter<br/>GET /status/:jobId]
        end
        
        subgraph "Compute Layer"
            C[Lambda: PediatricRcmFunction<br/>arm64, 3GB RAM, 300s timeout<br/>Multi-mode: Dispatcher + Worker]
        end
        
        subgraph "Storage Layer"
            D[DynamoDB: PediatricRcmResults<br/>PK: jobId<br/>Attributes: status, result, error]
        end
        
        subgraph "Container Registry"
            E[ECR Repository<br/>Image: pediatric-rcm-automation:latest<br/>Size: ~500MB compressed]
        end
        
        subgraph "Secrets Management"
            F[Secrets Manager<br/>PediatricRcmGeminiKey]
        end
        
        subgraph "Monitoring"
            G[CloudWatch Logs<br/>/aws/lambda/PediatricRcmFunction]
            H[CloudWatch Metrics<br/>Invocations, Duration, Errors]
        end
    end
    
    subgraph "External Services"
        I[Google Gemini API<br/>gemini-2.5-flash]
    end
    
    A -->|HTTPS| B
    B -->|Trigger| C
    C -->|Read/Write| D
    C -->|Self-invoke async| C
    C -->|Pull image| E
    C -->|Fetch secret| F
    C -->|Stream logs| G
    C -->|Emit metrics| H
    C -->|API calls| I
    
    style C fill:#FF9900,stroke:#232F3E,stroke-width:2px,color:#fff
    style B fill:#FF9900,stroke:#232F3E,stroke-width:2px,color:#fff
    style D fill:#3B48CC,stroke:#232F3E,stroke-width:2px,color:#fff
    style E fill:#FF9900,stroke:#232F3E,stroke-width:2px,color:#fff
    style I fill:#4285F4,stroke:#232F3E,stroke-width:2px,color:#fff
```

**Key Infrastructure Notes:**

- **Single Lambda Function**: Handles both API Gateway requests and async background processing via self-invocation
- **Docker Image**: ~500MB compressed, includes Python 3.13 runtime (ARM64), ADK libraries, all agent code, and knowledge base
- **DynamoDB Schema**: Primary key `jobId`, attributes include `status` ("Running"/"Completed"/"Failed"), `result` (final report), `error` (if failed)
- **IAM Permissions**: Managed by SAM - includes lambda:InvokeFunction, DynamoDB read/write, and Secrets Manager access
- **Cost Estimate**: Lambda ~$0.003/invocation (3GB × 60s avg), DynamoDB on-demand pricing, ECR ~$0.05/month, Gemini API varies by usage

---